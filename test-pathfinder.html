<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>PathFinder ç®—æ³•æµ‹è¯•</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    
    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }
    
    .test-section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    h2 {
      color: #2196F3;
      margin-top: 0;
    }
    
    .test-case {
      margin: 15px 0;
      padding: 15px;
      background: #f9f9f9;
      border-left: 4px solid #4CAF50;
      border-radius: 4px;
    }
    
    .test-case.failed {
      border-left-color: #f44336;
    }
    
    .test-case h3 {
      margin: 0 0 10px 0;
      color: #333;
      font-size: 16px;
    }
    
    .result {
      margin: 10px 0;
      padding: 10px;
      background: white;
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
    }
    
    .status {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 12px;
      margin-right: 10px;
    }
    
    .status.pass {
      background: #4CAF50;
      color: white;
    }
    
    .status.fail {
      background: #f44336;
      color: white;
    }
    
    .board-visual {
      display: inline-block;
      margin: 10px 0;
    }
    
    .board-row {
      display: flex;
    }
    
    .board-cell {
      width: 25px;
      height: 25px;
      border: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      background: white;
    }
    
    .board-cell.wall-top { border-top: 3px solid #333; }
    .board-cell.wall-right { border-right: 3px solid #333; }
    .board-cell.wall-bottom { border-bottom: 3px solid #333; }
    .board-cell.wall-left { border-left: 3px solid #333; }
    .board-cell.blocked { background: #333; }
    .board-cell.robot { background: #2196F3; color: white; font-weight: bold; }
    .board-cell.target { background: #4CAF50; color: white; }
    .board-cell.prism { background: #FF9800; }
    
    .path-info {
      margin-top: 10px;
      padding: 10px;
      background: #e3f2fd;
      border-radius: 4px;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    
    .stat-item {
      padding: 10px;
      background: white;
      border-radius: 4px;
      text-align: center;
    }
    
    .stat-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }
    
    .stat-value {
      font-size: 20px;
      font-weight: bold;
      color: #2196F3;
    }
    
    .summary {
      position: sticky;
      top: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.2);
    }
    
    .summary h2 {
      color: white;
      margin: 0 0 15px 0;
    }
  </style>
</head>
<body>
  <h1>ğŸ¯ PathFinder ç®—æ³•æµ‹è¯•</h1>
  
  <div class="summary" id="summary">
    <h2>æµ‹è¯•æ€»ç»“</h2>
    <div class="stats" id="summaryStats"></div>
  </div>
  
  <div id="testResults"></div>
  
  <script type="module">
    import CONSTANTS from './src/utils/Constants.js';
    import { Cell } from './src/core/Cell.js';
    import { Prism } from './src/core/Prism.js';
    import { Target } from './src/core/Target.js';
    import { Robot } from './src/core/Robot.js';
    import { Board } from './src/core/Board.js';
    import { SmallBoard } from './src/core/SmallBoard.js';
    import { PathFinder } from './src/algorithm/PathFinder.js';
    
    // æµ‹è¯•ç»“æœå®¹å™¨
    const results = {
      total: 0,
      passed: 0,
      failed: 0,
      tests: []
    };
    
    // æµ‹è¯•è¾…åŠ©å‡½æ•°
    function test(name, fn) {
      const testCase = {
        name,
        status: 'pass',
        message: '',
        time: 0,
        details: null
      };
      
      try {
        const start = performance.now();
        const result = fn();
        testCase.time = (performance.now() - start).toFixed(2);
        testCase.details = result;
        results.passed++;
      } catch (error) {
        testCase.status = 'fail';
        testCase.message = error.message;
        results.failed++;
        console.error(`Test failed: ${name}`, error);
      }
      
      results.total++;
      results.tests.push(testCase);
    }
    
    // åˆ›å»ºç®€å•çš„æµ‹è¯•æ£‹ç›˜ï¼ˆæ— åˆ†å…‰é•œï¼‰
    function createSimpleTestBoard() {
      // åˆ›å»ºä¸€ä¸ªç®€å•çš„å°æ£‹ç›˜æ•°æ®
      const smallBoardData = {
        id: 0,
        color: 'red',
        originalGap: { x: 0, y: 0 },
        faces: [
          {
            id: 0,
            walls: [
              // æ·»åŠ ä¸€äº›å¢™å£ä½œä¸º"åœé ç‚¹"ï¼Œä½¿å¾—å¯ä»¥ç²¾ç¡®åœåœ¨æŸäº›ä½ç½®
              { x: 3, y: 2, sides: ['bottom'] },  // åœ¨(3,2)ä¸‹æ–¹æœ‰å¢™
              { x: 2, y: 3, sides: ['right'] }    // åœ¨(2,3)å³ä¾§æœ‰å¢™
            ],
            prisms: [],
            targets: [
              // ä½¿ç”¨(3,2)ä½œä¸ºç»ˆç‚¹ï¼Œæ—‹è½¬180åº¦åå˜æˆ(4,5)
              // è¿™ä¸ªä½ç½®æ›´å®¹æ˜“åˆ°è¾¾
              { x: 3, y: 2, shape: 'circle', color: 'rainbow', id: 'target-0' }
            ]
          }
        ]
      };
      
      const smallBoard = new SmallBoard(smallBoardData);
      
      // åˆ›å»ºå…¶ä»–3ä¸ªç©ºçš„å°æ£‹ç›˜ï¼ˆåªæ˜¯ä¸ºäº†æ»¡è¶³Boardçš„è¦æ±‚ï¼‰
      const emptyBoards = ['yellow', 'blue', 'green'].map((color, idx) => {
        return new SmallBoard({
          id: idx + 1,
          color: color,
          originalGap: { x: 0, y: 0 },
          faces: [
            {
              id: 0,
              walls: [],
              prisms: [],
              targets: []
            }
          ]
        });
      });
      
      const allBoards = [smallBoard, ...emptyBoards];
      
      // åˆ›å»ºå¤§æ£‹ç›˜é…ç½®
      const config = [
        { boardId: 0, faceId: 0 },
        { boardId: 1, faceId: 0 },
        { boardId: 2, faceId: 0 },
        { boardId: 3, faceId: 0 }
      ];
      
      return { board: new Board(config, allBoards), allBoards };
    }
    
    // åˆ›å»ºå¸¦åˆ†å…‰é•œçš„æµ‹è¯•æ£‹ç›˜
    function createPrismTestBoard() {
      const smallBoardData = {
        id: 0,
        color: 'red',
        originalGap: { x: 0, y: 0 },
        faces: [
          {
            id: 0,
            walls: [],
            prisms: [
              { x: 4, y: 4, direction: '\\', color: 'yellow' }
            ],
            targets: [
              // ä½¿ç”¨(3,3)ä½œä¸ºç»ˆç‚¹ï¼Œæ—‹è½¬180åº¦åå˜æˆ(4,4)
              // æ³¨æ„ï¼šè¿™ä¸åˆ†å…‰é•œåœ¨åŒä¸€ä½ç½®ï¼Œä½†æµ‹è¯•ä¸éœ€è¦åˆ°è¾¾ç»ˆç‚¹
              { x: 5, y: 5, shape: 'circle', color: 'rainbow', id: 'target-0' }
            ]
          }
        ]
      };
      
      const smallBoard = new SmallBoard(smallBoardData);
      
      const emptyBoards = ['yellow', 'blue', 'green'].map((color, idx) => {
        return new SmallBoard({
          id: idx + 1,
          color: color,
          originalGap: { x: 0, y: 0 },
          faces: [
            {
              id: 0,
              walls: [],
              prisms: [],
              targets: []
            }
          ]
        });
      });
      
      const allBoards = [smallBoard, ...emptyBoards];
      
      const config = [
        { boardId: 0, faceId: 0 },
        { boardId: 1, faceId: 0 },
        { boardId: 2, faceId: 0 },
        { boardId: 3, faceId: 0 }
      ];
      
      return { board: new Board(config, allBoards), allBoards };
    }
    
    // ==================== æµ‹è¯•å¥—ä»¶ ====================
        
    // æµ‹è¯•1: åŸºæœ¬ç§»åŠ¨æ¨¡æ‹Ÿï¼ˆæ— åˆ†å…‰é•œï¼‰
    test('åŸºæœ¬ç§»åŠ¨æ¨¡æ‹Ÿ - å‘å³ç§»åŠ¨', () => {
      const { board } = createSimpleTestBoard();
      const robots = [
        new Robot('red', 0, 0),
        new Robot('yellow', 8, 0),
        new Robot('blue', 0, 8),
        new Robot('green', 8, 8)
      ];
      
      const pathFinder = new PathFinder(board, robots);
      const result = pathFinder.simulateMove(
        { color: 'red', x: 0, y: 0 },
        'right',
        robots.map(r => ({ color: r.color, x: r.x, y: r.y }))
      );
      
      if (!result.moved) throw new Error('åº”è¯¥èƒ½å¤Ÿç§»åŠ¨');
      if (result.finalY !== 0) throw new Error('Yåæ ‡ä¸åº”æ”¹å˜');
      if (result.finalX <= 0) throw new Error('Xåæ ‡åº”è¯¥å¢åŠ ');
      if (result.segments.length !== 1) throw new Error('åº”è¯¥åªæœ‰ä¸€ä¸ªç§»åŠ¨æ®µ');
      
      return { result, message: `ä»(0,0)å‘å³ç§»åŠ¨åˆ°(${result.finalX},${result.finalY})` };
    });
    
    // æµ‹è¯•2: ç¢°åˆ°è¾¹ç•Œ
    test('ç§»åŠ¨é‡åˆ°è¾¹ç•Œåœæ­¢', () => {
      const { board } = createSimpleTestBoard();
      const robots = [
        new Robot('red', 15, 0),
        new Robot('yellow', 8, 0),
        new Robot('blue', 0, 8),
        new Robot('green', 8, 8)
      ];
      
      const pathFinder = new PathFinder(board, robots);
      const result = pathFinder.simulateMove(
        { color: 'red', x: 15, y: 0 },
        'right',
        robots.map(r => ({ color: r.color, x: r.x, y: r.y }))
      );
      
      if (result.moved) throw new Error('ä¸åº”è¯¥èƒ½å¤Ÿç§»åŠ¨ï¼ˆå·²åœ¨è¾¹ç•Œï¼‰');
      if (result.finalX !== 15 || result.finalY !== 0) throw new Error('ä½ç½®ä¸åº”æ”¹å˜');
      
      return { result, message: 'åœ¨è¾¹ç•Œå¤„æ— æ³•ç»§ç»­ç§»åŠ¨' };
    });
    
    // æµ‹è¯•3: ç¢°åˆ°å…¶ä»–æ£‹å­
    test('ç§»åŠ¨é‡åˆ°å…¶ä»–æ£‹å­åœæ­¢', () => {
      const { board } = createSimpleTestBoard();
      const robots = [
        new Robot('red', 0, 0),
        new Robot('yellow', 5, 0), // æŒ¡åœ¨çº¢è‰²æ£‹å­çš„è·¯ä¸Š
        new Robot('blue', 0, 8),
        new Robot('green', 8, 8)
      ];
      
      const pathFinder = new PathFinder(board, robots);
      const result = pathFinder.simulateMove(
        { color: 'red', x: 0, y: 0 },
        'right',
        robots.map(r => ({ color: r.color, x: r.x, y: r.y }))
      );
      
      if (!result.moved) throw new Error('åº”è¯¥èƒ½å¤Ÿç§»åŠ¨');
      if (result.finalX !== 4) throw new Error(`åº”è¯¥åœåœ¨(4,0)ï¼Œå®é™…ä¸º(${result.finalX},${result.finalY})`);
      
      return { result, message: `ä»(0,0)ç§»åŠ¨åˆ°(${result.finalX},0)ï¼Œè¢«æ£‹å­æŒ¡ä½` };
    });
    
    // æµ‹è¯•4: ä¸­å¤®åŒºåŸŸé˜»æŒ¡
    test('ç§»åŠ¨é‡åˆ°ä¸­å¤®åŒºåŸŸåœæ­¢', () => {
      const { board } = createSimpleTestBoard();
      const robots = [
        new Robot('red', 5, 7),
        new Robot('yellow', 8, 0),
        new Robot('blue', 0, 8),
        new Robot('green', 8, 8)
      ];
      
      const pathFinder = new PathFinder(board, robots);
      const result = pathFinder.simulateMove(
        { color: 'red', x: 5, y: 7 },
        'down',
        robots.map(r => ({ color: r.color, x: r.x, y: r.y }))
      );
      
      // ä¸­å¤®åŒºåŸŸæ˜¯(7,7)åˆ°(8,8)ï¼Œæ‰€ä»¥ä»(5,7)å‘ä¸‹ç§»åŠ¨åº”è¯¥åœ¨(5,7)åœæ­¢æˆ–ç§»åˆ°(5,6)ï¼ˆå–å†³äºå¢™å£ï¼‰
      // å®é™…ä¸Šåº”è¯¥è¢«ä¸­å¤®åŒºåŸŸçš„å¢™å£æŒ¡ä½
      
      return { result, message: `ä»(5,7)å‘ä¸‹ç§»åŠ¨è¢«ä¸­å¤®åŒºåŸŸé˜»æŒ¡` };
    });
    
    // æµ‹è¯•5: ç®€å•è·¯å¾„æœç´¢ï¼ˆæ— åˆ†å…‰é•œï¼‰
    test('ç®€å•è·¯å¾„æœç´¢ - ç›´æ¥åˆ°è¾¾', () => {
      const { board } = createSimpleTestBoard();
      
      // å°†é»„è‰²æ£‹å­æ”¾åœ¨(4,5)ä½œä¸ºéšœç¢ç‰©/åœé ç‚¹
      const robots = [
        new Robot('red', 0, 0),
        new Robot('yellow', 4, 5),  // é»„è‰²åœ¨ç›®æ ‡ä½ç½®ï¼Œä½œä¸ºéšœç¢
        new Robot('blue', 0, 8),
        new Robot('green', 8, 8)
      ];
      
      // æŸ¥æ‰¾ç»ˆç‚¹ä½ç½®
      const targets = board.getAllTargets();
      console.log('All targets:', targets.map(t => ({x:t.x, y:t.y, color:t.color, shape:t.shape})));
      
      if (targets.length === 0) {
        throw new Error('No targets found!');
      }
      
      const target = targets[0];
      console.log('Target position:', target.x, target.y);
      console.log('Yellow robot at:', 4, 5);
      
      // ç›®æ ‡æ”¹ä¸ºé»„è‰²æ£‹å­å½“å‰ä½ç½®æ—è¾¹ï¼Œè®©çº¢è‰²æ¨å¼€é»„è‰²ååˆ°è¾¾
      // æˆ–è€…å¹²è„†æµ‹è¯•åˆ°è¾¾ä¸€ä¸ªè‚¯å®šèƒ½åˆ°çš„ä½ç½®
      const pathFinder = new PathFinder(board, robots);
      
      // å…ˆæµ‹è¯•çº¢è‰²èƒ½åˆ°è¾¾çš„ä½ç½® - è¾¹ç•Œä½ç½®
      const testTarget = { x: 7, y: 0 }; // çº¢è‰²å‘å³æ»‘åˆ°ä¸­å¤®åŒºåŸŸå‰
      
      const result = pathFinder.findPath('red', testTarget, true);
      
      console.log('Path search result:', result);
      
      if (!result.success) {
        // å¦‚æœè¿è¾¹ç•Œéƒ½åˆ°ä¸äº†ï¼Œè¯´æ˜æœ‰ä¸¥é‡é—®é¢˜
        throw new Error(`è·¯å¾„æœç´¢å¤±è´¥: ${result.message}ï¼Œç›®æ ‡(${testTarget.x},${testTarget.y})`);
      }
      
      // æ£€æŸ¥æ˜¯å¦è‡³å°‘2æ­¥
      if (result.steps < 2) {
        throw new Error(`æ‰¾åˆ°äº†1æ­¥è§£ï¼Œä½†è§„åˆ™è¦æ±‚è‡³å°‘2æ­¥ã€‚è¿™ä¸ªæµ‹è¯•éœ€è¦æ›´å¤æ‚çš„åœºæ™¯ã€‚`);
      }
      
      if (!result.path || result.path.length === 0) throw new Error('è·¯å¾„ä¸åº”ä¸ºç©º');
      
      return {
        result,
        message: `æ‰¾åˆ°è·¯å¾„åˆ°(${testTarget.x},${testTarget.y})ï¼Œ${result.steps}æ­¥ï¼Œæ¢ç´¢${result.statesExplored}ä¸ªçŠ¶æ€ï¼Œè€—æ—¶${result.time.toFixed(2)}ms`
      };
    });
    
    // æµ‹è¯•6: è·å–å¯èƒ½çš„ç§»åŠ¨
    test('è·å–æ£‹å­çš„æ‰€æœ‰å¯èƒ½ç§»åŠ¨', () => {
      const { board } = createSimpleTestBoard();
      const robots = [
        new Robot('red', 5, 5),
        new Robot('yellow', 8, 0),
        new Robot('blue', 0, 8),
        new Robot('green', 8, 8)
      ];
      
      const pathFinder = new PathFinder(board, robots);
      const moves = pathFinder.getPossibleMoves('red');
      
      if (!Array.isArray(moves)) throw new Error('åº”è¯¥è¿”å›æ•°ç»„');
      // ä»ä¸­å¿ƒä½ç½®åº”è¯¥èƒ½å¤Ÿå‘4ä¸ªæ–¹å‘ç§»åŠ¨
      if (moves.length === 0) throw new Error('åº”è¯¥æœ‰è‡³å°‘ä¸€ä¸ªå¯èƒ½çš„ç§»åŠ¨');
      
      return {
        moves,
        message: `çº¢è‰²æ£‹å­æœ‰${moves.length}ä¸ªå¯èƒ½çš„ç§»åŠ¨`
      };
    });
    
    // æµ‹è¯•7: å·²åœ¨ç›®æ ‡ä½ç½®
    test('æ£‹å­å·²åœ¨ç›®æ ‡ä½ç½®', () => {
      const { board } = createSimpleTestBoard();
      const robots = [
        new Robot('red', 6, 6), // å·²ç»åœ¨ç›®æ ‡ä½ç½®
        new Robot('yellow', 8, 0),
        new Robot('blue', 0, 8),
        new Robot('green', 8, 8)
      ];
      
      const pathFinder = new PathFinder(board, robots);
      const result = pathFinder.findPath('red', { x: 6, y: 6 });
      
      if (!result.success) throw new Error('åº”è¯¥æˆåŠŸ');
      if (result.steps !== 0) throw new Error('æ­¥æ•°åº”è¯¥ä¸º0');
      if (result.path.length !== 0) throw new Error('è·¯å¾„åº”è¯¥ä¸ºç©º');
      
      return { result, message: 'å·²åœ¨ç›®æ ‡ä½ç½®ï¼Œ0æ­¥' };
    });
    
    // æµ‹è¯•8: åˆ†å…‰é•œæŠ˜å°„ï¼ˆå¼‚è‰²ï¼‰
    test('åˆ†å…‰é•œæŠ˜å°„ - å¼‚è‰²æ£‹å­', () => {
      const { board } = createPrismTestBoard();
      
      // æ‰¾åˆ°åˆ†å…‰é•œä½ç½®
      let prismPos = null;
      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          const cell = board.getCell(x, y);
          if (cell && cell.hasPrism()) {
            console.log(`Found prism at (${x},${y}):`, cell.prism);
            prismPos = {x, y, prism: cell.prism};
          }
        }
      }
      
      if (!prismPos) {
        throw new Error('No prism found in board!');
      }
      
      const robots = [
        new Robot('red', prismPos.x, 0), // çº¢è‰²æ£‹å­åœ¨åˆ†å…‰é•œæ­£ä¸Šæ–¹
        new Robot('yellow', 8, 0),
        new Robot('blue', 0, 8),
        new Robot('green', 8, 8)
      ];
      
      // çº¢è‰²æ£‹å­ä»åˆ†å…‰é•œæ­£ä¸Šæ–¹å‘ä¸‹ç§»åŠ¨ï¼Œä¼šåœ¨åˆ†å…‰é•œå¤„è¢«æŠ˜å°„
      const pathFinder = new PathFinder(board, robots);
      const result = pathFinder.simulateMove(
        { color: 'red', x: prismPos.x, y: 0 },
        'down',
        robots.map(r => ({ color: r.color, x: r.x, y: r.y }))
      );
      
      console.log('Refraction test result:', result);
      
      // çº¢è‰²é‡åˆ°é»„è‰²åˆ†å…‰é•œï¼ˆæ—‹è½¬åï¼‰ï¼šåº”è¯¥è¢«æŠ˜å°„
      if (!result.moved) throw new Error('åº”è¯¥èƒ½å¤Ÿç§»åŠ¨');
      if (result.segments.length < 2) {
        throw new Error(`åº”è¯¥æœ‰å¤šä¸ªç§»åŠ¨æ®µï¼ˆæŠ˜å°„ï¼‰ï¼Œå®é™…${result.segments.length}æ®µ: ${JSON.stringify(result.segments)}`);
      }
      
      return {
        result,
        message: `çº¢è‰²æ£‹å­è¢«é»„è‰²åˆ†å…‰é•œæŠ˜å°„ï¼Œ${result.segments.length}ä¸ªç§»åŠ¨æ®µï¼Œåˆ†å…‰é•œåœ¨(${prismPos.x},${prismPos.y})`
      };
    });
    
    // æµ‹è¯•9: åˆ†å…‰é•œæŠ˜å°„ï¼ˆåŒè‰²ï¼‰
    test('åˆ†å…‰é•œæŠ˜å°„ - åŒè‰²æ£‹å­ç›´é€š', () => {
      const { board } = createPrismTestBoard();
      
      // æ‰¾åˆ°åˆ†å…‰é•œä½ç½®
      let prismPos = null;
      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          const cell = board.getCell(x, y);
          if (cell && cell.hasPrism() && cell.prism.color === 'yellow') {
            prismPos = {x, y};
            break;
          }
        }
        if (prismPos) break;
      }
      
      if (!prismPos) {
        throw new Error('Yellow prism not found!');
      }
      
      const robots = [
        new Robot('red', 8, 0),
        new Robot('yellow', prismPos.x, 0), // é»„è‰²æ£‹å­åœ¨åˆ†å…‰é•œæ­£ä¸Šæ–¹
        new Robot('blue', 0, 8),
        new Robot('green', 8, 8)
      ];
      
      // é»„è‰²æ£‹å­å‘ä¸‹ç§»åŠ¨ï¼Œåº”è¯¥ç›´é€š
      const pathFinder = new PathFinder(board, robots);
      const result = pathFinder.simulateMove(
        { color: 'yellow', x: prismPos.x, y: 0 },
        'down',
        robots.map(r => ({ color: r.color, x: r.x, y: r.y }))
      );
      
      if (!result.moved) throw new Error('åº”è¯¥èƒ½å¤Ÿç§»åŠ¨');
      // åŒè‰²åº”è¯¥åªæœ‰ä¸€ä¸ªç§»åŠ¨æ®µï¼ˆç›´é€šï¼‰
      if (result.segments.length !== 1) {
        throw new Error(`åŒè‰²åº”è¯¥ç›´é€šï¼Œåªæœ‰ä¸€ä¸ªç§»åŠ¨æ®µï¼Œå®é™…${result.segments.length}ä¸ª`);
      }
      
      return {
        result,
        message: `é»„è‰²æ£‹å­é‡åˆ°é»„è‰²åˆ†å…‰é•œç›´é€šï¼Œ${result.segments.length}ä¸ªç§»åŠ¨æ®µï¼Œåˆ†å…‰é•œåœ¨(${prismPos.x},${prismPos.y})`
      };
    });
    
    // æµ‹è¯•10: æ€§èƒ½æµ‹è¯•
    test('æ€§èƒ½æµ‹è¯• - å¤æ‚æœç´¢', () => {
      const { board } = createSimpleTestBoard();
      const robots = [
        new Robot('red', 0, 0),
        new Robot('yellow', 15, 0),
        new Robot('blue', 0, 15),
        new Robot('green', 15, 15)
      ];
      
      // æµ‹è¯•åˆ°è¾¾è¾¹ç•Œä½ç½®
      const testTarget = { x: 7, y: 0 };
      
      const pathFinder = new PathFinder(board, robots);
      const startTime = performance.now();
      const result = pathFinder.findPath('red', testTarget);
      const elapsed = performance.now() - startTime;
      
      if (!result.success) {
        throw new Error(`æœç´¢å¤±è´¥: ${result.message}ï¼Œç›®æ ‡(${testTarget.x},${testTarget.y})`);
      }
      
      if (elapsed > 1000) throw new Error(`æœç´¢æ—¶é—´è¿‡é•¿: ${elapsed}ms`);
      
      return {
        result,
        message: `æœç´¢å®Œæˆåˆ°(${testTarget.x},${testTarget.y})ï¼Œ${result.statesExplored}ä¸ªçŠ¶æ€ï¼Œè€—æ—¶${elapsed.toFixed(2)}ms`
      };
    });
    
    // ==================== æ˜¾ç¤ºæµ‹è¯•ç»“æœ ====================
    
    function displayResults() {
      const container = document.getElementById('testResults');
      const summaryEl = document.getElementById('summaryStats');
      
      // æ˜¾ç¤ºæ€»ç»“
      summaryEl.innerHTML = `
        <div class="stat-item">
          <div class="stat-label">æ€»æµ‹è¯•æ•°</div>
          <div class="stat-value">${results.total}</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">é€šè¿‡</div>
          <div class="stat-value" style="color: #4CAF50">${results.passed}</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">å¤±è´¥</div>
          <div class="stat-value" style="color: #f44336">${results.failed}</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">é€šè¿‡ç‡</div>
          <div class="stat-value">${((results.passed / results.total) * 100).toFixed(1)}%</div>
        </div>
      `;
      
      // æ˜¾ç¤ºæ¯ä¸ªæµ‹è¯•
      results.tests.forEach(test => {
        const testDiv = document.createElement('div');
        testDiv.className = `test-case ${test.status === 'fail' ? 'failed' : ''}`;
        
        let detailsHTML = '';
        if (test.details) {
          detailsHTML = `
            <div class="result">
              ${JSON.stringify(test.details, null, 2)}
            </div>
          `;
        }
        
        testDiv.innerHTML = `
          <h3>
            <span class="status ${test.status === 'pass' ? 'pass' : 'fail'}">
              ${test.status === 'pass' ? 'âœ“ PASS' : 'âœ— FAIL'}
            </span>
            ${test.name}
            <span style="color: #999; font-size: 12px; float: right;">${test.time}ms</span>
          </h3>
          ${test.message ? `<p style="color: #f44336;">${test.message}</p>` : ''}
          ${detailsHTML}
        `;
        
        container.appendChild(testDiv);
      });
    }
    
    // æ˜¾ç¤ºç»“æœ
    displayResults();
    
    console.log('\n=== æµ‹è¯•å®Œæˆ ===');
    console.log(`æ€»è®¡: ${results.total}, é€šè¿‡: ${results.passed}, å¤±è´¥: ${results.failed}`);
  </script>
</body>
</html>

